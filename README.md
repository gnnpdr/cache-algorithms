## Алгоритмы кэширования Belady и LFU

### Запуск

Скопируйте репозиторий.
Перейдите в папку с проектом, соберите все таргеты
```
cmake -B build -S . && cmake --build build -j4
```
Есть несколько таргетов 
```
./build/LFU_tests
./build/Belady_tests
./build/ef_Belady_tests
```
запустят соответствующие программные тесты и выведут результат. Содержание тестов можно увидеть в файле tests/include/tests.hpp, из них видно, что эффективность ef_Belady больше, чем у Belady.

```
./build/efficiency_test
```
измерит эффективность работы разных алгоритмов кэширования и выведут процент попаданий при измерении на одном большом тесте в 400000 запросов. Содержание теста в файле tests/include/big_test.dat.

Результаты программы такие

**ef_Belady:**
Hit rate: 31%

**Belady:**
Hit rate: 31%

**LFU:**
Hit rate: 20%

как и ожидалось, процент попаданий для неидеального кэша меньше, чем для идеального.

```
./build/LFU
./build/Belady
./build/ef_Belady
```
запустят соответствующий кэш. Заполнение с командной строки после запуска в порядке: размер кэша, количество элементов и сами элементы. Будет выведено количество попаданий.


### Алгоритмы

В идеальном кэше (Belady) заранее известен весь порядок запросов, алгоритм заключается в том, чтобы при кэшмисе вытеснять элемент, который будет использован позже всех. 

Также представлен более эффективный алгоритм (ef_Belady) изменения в том, что если новый элемент не попадает в кэш и никогда больше не встретится, мы его игнорируем, кэш остается в исходном состоянии. Если новый элемент еще встретится, но его следующая позиция в очереди запросов дальше, чем у первого претендента на вытеснение, то этот элемент тоже игнорируется. 

В LFU вытесняются те элементы, которые реже всех попадали в кэш. При попадании увеличивается счетчик, элемент с наименьшим значением счетчика удаляется. При этом значение счетчика обнуляется. То есть если элемент со счетчиком 2 вылетел из кэша, то при возвращении начальным значением будет 1.


Выберем контейнеры, которые нужно использовать. 


Для идеального кэша нам нужно, чтобы элементы были отсортированы по положению следующего запроса, тогда можно будет быстро найти элемент, от которого нужно избавиться при кэшмисе. Используем упорядоченное множество. При этом нам нужно быстро проверять, есть ли элемент в кэше. То есть хотелось бы находить ячейку по ключу. Значит, нужна хеш-таблица, связывающая ключи-значения и ячейки упорядоченного множества. 


Для LFU нужно хранить значения попаданий. Тогда при каждом попадании нужно будет обновлять ячейку, как и было в идеальном. Можно использовать те же контейнеры для этого, изменив условие упорядочивания.